---
title: "TREATMENT OF BIOLOGIC DATA FROM CSLN BEFORE SDM TREATMENT"
author: "Am√©lie Lehuen"
date: "2022-12-14"
description: "add info on script"
toc: true # table of content at beginning of document
number-sections: true
highlight-style: pygments
format: 
  html: 
    self-contained: true
    code-fold: false
    html-math-method: katex # displays equations
  pdf:
    code-line-numbers: true
    geometry: 
      - top=20mm
      - left=20mm
  docx: 
    reference-doc: default

bibliography: references.bib

editor: visual
execute:
  eval: true
  echo: false
  message: false
  warning: false
  output: true
  include: false
  cache: false
---

# TREATMENT OF BIOLOGIC DATA FROM CSLN BEFORE SDM TREATMENT

## Script preparation

### Packages

```{r}
#| label: load-packages
#| code-summary: "Packages"

library(readxl) ; library(openxlsx) # Edition d'un fichier Excel
library(tidyverse) #The toolbox indispensable
library(vegan) # environmental data processing (diversity, adonis2,metaMDS,vegdist)
library(labdsv) # Community analysis (invdal)
# install.packages("devtools"); library(devtools);Sys.setenv("R_REMOTES_NO_ERRORS_FROM_WARNINGS"=TRUE)
# install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(pairwiseAdonis) #(pairwise.adonis)
library(pastecs)
library(clustsig) # WARNING NOT ANY MORE IN CRAN https://CRAN.R-project.org/package=clustsig
library(dendextend) # # Analyse TPA (abund); Analyse SIMPROF (simprof); library(ggdendro) ggdendrogramm
library(broom)
library(purrr) # Multiple lm at once : tidy,glance,augment
# Graphics packages
library(RColorBrewer)
library(wesanderson) # Palettes de couleurs
library(ggpubr);
library(treemap) # treemap
options(scipen=999) # Prevents scientific display of numbers
library(knitr)
```

### Working Environment

```{r}
#| label: workenvir
#| echo: true
rm(list=ls())
# pc <- "C:/Users/lehuen201/Nextcloud/" # "E:/" # 
# tsk <- "A_SDM_NEO/"
wdtask <- "../" #paste(pc,"Melting Pot/BDD/",tsk,sep="")
wdsource <- paste(wdtask,"Sources/Faune/CSLN_mud_l/",sep="")
wdwork <- paste(wdtask,"Matrices/",sep="")
wdgraph <- paste(wdtask,"Graphiques/",sep="")
wdres <- paste(wdtask,"Resultats/",sep="")
# setwd(wdtask)
```

### Graphic charter

```{r}
#| label: graphchart
theme_set(theme_bw(base_size = 16)) # theme_gray() theme_bw() theme_light() theme_dark()
colDarj <- function(x) {wes_palette("Darjeeling2",x, type = "continuous")}
colZiss <- function(x) {wes_palette("Zissou1",x, type = "continuous")}
colSpec <- colorRampPalette(brewer.pal(11, "Spectral")); 
colDark <- colorRampPalette(brewer.pal(8, "Dark2"));
Scale_col <- function(x) {scale_colour_manual(values=colDarj(x))}
Scale_fill <- function(x) {scale_fill_manual(values=colDarj(x))}
Scale_brew <- function() {scale_colour_brewer(palette="Spectral",aesthetics=c("colour","fill"))}

```

### Home made functions

```{r}
#| label: functmade
#| echo: true

```

## Load of External data and Basic Variables

### External data

```{r}
#| label: externdata
#| echo: true
rdatain <- sprintf("%sCSLN_Mars_BDD.RData",wdwork)
load(rdatain)
```

### Output binder and data

```{r}
#| label: outfiles
#| echo: true
binderout <- sprintf("binderout.xlsx")
rdataout  <- sprintf("%sCSLN_Mars_Zone_BDD.RData",wdwork)
# if exists
# load(rdataout)
```

### Basic variables

```{r}
#| label: basicvar
#| echo: true
discarded_run <- c("")
nelrow <- 2; nelcol <- 1
```

# Global analysis of communities

## Selection of data

(ONLY MUDFLAT done previously) FOR GIPSA

```{r}
#| label: calculation_1

CSLN_mud_l <- CSLN %>%
  filter(grepl("Mudflat", Zone)) %>%
  select(idStationUnique,Station_originelle,
         Zone,Period,Tidal_level,Annee,
         SP,SPCourt,Taxon_SNa,
         Biomass_gAFDWm2,Density_indm2,MSRtot,BPc)
CSLN_mud_Spch <- CSLN_mud_l %>% 
  filter(SP == "SpCh", 
         !is.na(MSRtot),!is.na(BPc),
         BPc < 8000, MSRtot < 75)
```

#### Anova between period and zones

```{r}
#| label: calculation_2

# perm <- adonis2(CSLN_mud_BTA ~ Zone)
# pairwise.adonis(CSLN_mud_BTA, CSLN_mud_BTA$Period)
CSLN_mud_BTA_names <- CSLN_mud_BTA %>% 
  select(Zone,Tidal_level,Period,Annee) %>%
  unite("ZP", Zone, Period, sep = "_", remove = FALSE) %>%
  unite("ZA", Zone, Annee, sep = "_", remove = FALSE) %>%
  unite("PAZ", Period, Annee, Zone, sep = "_", remove = FALSE)

# MSR
aov_MSR <- aov(MSRtot ~ Period * Zone, 
               data = CSLN_mud_Spch)

shapiro.test(aov_MSR$residuals)
ggqqplot(residuals(aov_MSR))
bartlett.test(MSRtot ~ Period, data = CSLN_mud_Spch)

bartlett.test(MSR.ZTPAS ~ Zone, data = CSLN_mud_BTA)
BTA_cont <- as.matrix(CSLN_mud_BTA[,"MSR.ZTPAS"])
row.names(BTA_cont) <- CSLN_mud_BTA_names$PAZ
BTA_cont_names <- subset(CSLN_mud_BTA_names, 
                         rowSums(BTA_cont) != 0) #
BTA_cont <- subset(BTA_cont, rowSums(BTA_cont) != 0) #

MSR_ado  <- adonis2(
  BTA_cont ~ BTA_cont_names$Period * BTA_cont_names$Zone,
  method = "bray", permutations = 999)

padZ <- pairwise.adonis(BTA_cont, BTA_cont_names$Zone)
padP <- pairwise.adonis(BTA_cont, BTA_cont_names$Period)
padZP <- pairwise.adonis(BTA_cont, BTA_cont_names$ZP)
MSR_padsig <- as.data.frame(rbind(padZ, padP, padZP)) %>%
  filter(sig != "")

# BPc
aov_BPc <- aov(BPc ~ Period * Zone, 
               data = CSLN_mud_Spch) #

shapiro.test(aov_BPc$residuals)
ggqqplot(residuals(aov_BPc))
bartlett.test(BPc ~ Period, data = CSLN_mud_Spch)

bartlett.test(BPc.ZTPAS ~ Zone, data = CSLN_mud_BTA)
BTA_cont <- as.matrix(CSLN_mud_BTA[,"BPc.ZTPAS"])
row.names(BTA_cont) <- CSLN_mud_BTA_names$PAZ
BTA_cont_names <- subset(CSLN_mud_BTA_names, 
                         rowSums(BTA_cont) != 0) #
BTA_cont <- subset(BTA_cont, rowSums(BTA_cont) != 0) #

BPc_ado  <- adonis2(
  BTA_cont ~ BTA_cont_names$Period * BTA_cont_names$Zone,
  method = "bray", permutations = 999)

padZ <- pairwise.adonis(BTA_cont, BTA_cont_names$Zone)
padP <- pairwise.adonis(BTA_cont, BTA_cont_names$Period)
padZP <- pairwise.adonis(BTA_cont, BTA_cont_names$ZP)
BPc_padsig <- as.data.frame(rbind(padZ, padP, padZP)) %>% filter(sig != "")

```

### ANCOVA BTA

MIEUX DEFINIR LES UNITES DU CALCUL BPc ET SON USAGE + DIFF DE RESULTAT AVEC MAXIME

```{r}
#| label: calculation_3

# CSLN_mud_BTA_lm1 <- lm(CSLN_mud_Spch$BPc ~ CSLN_mud_Spch$MSRtot * CSLN_mud_Spch$Taxon_SNa)
CSLN_mud_BTA_lm <- CSLN_mud_Spch %>% 
  nest(data = -c(Taxon_SNa))  %>%
  mutate(model = map(data, ~lm(BPc ~ MSRtot, data = .)),
         tidied = map(model, tidy)) %>% #,
  # glanced = map(model, glance),
  # augmented = map(model, augment)) %>%
  select(-c(data,model)) %>%
  unnest(tidied) 
# CSLN_mud_BTA_lm %>% unnest(glanced)
# CSLN_mud_BTA_lm %>% unnest(augmented)

gp  <- ggplot(CSLN_mud_Spch,
            aes(y = BPc, x = MSRtot, colour = Taxon_SNa)) +
  geom_point() +
  geom_smooth(method = "lm") + 
  stat_regline_equation(
    aes(label =  paste(..eq.label.., ..rr.label.., 
                       sep = "~~~~"),color = Taxon_SNa)) +
  Scale_brew()+
  labs(y = "BPc", x = "MSR (mW/m2)", color = "Species"); gp

```

## RARE SPECIES - TPA

David, V., 2017. Traitement de donn?es en sciences environnementales, ISTE Editions. ed, Ecologie. Page 44

The Abundance Sorting method (TPA :Tri Par Abondance) was adapted from Ibanez et al (1993) in the pastecs package (abund). It takes into account both the number of 0 present in the database for a given speciesMP, but also the rare speciesMP (absent from many stations) but abundant for some stations.

A coefficient f, between 0 and 1, allows to adjust the weight given to the frequency of null values for a speciesMP (f=0 if only this criterion is taken into account) and to the abundance of speciesMP expressed in log

```{r}
#| label: calculation_4

CSLN_abd <- abund(CSLN_cont_mat,f=0.2) #f=0,2 recommande
# Find where our speciesMP are in the TPA order to keep them
# intersect(colnames(extract(CSLN_abd,length(CSLN_abd$vr))),speciesMP[,1])

# Find the last rank of our speciesMP
minSpecies <- max(which(colnames(extract(CSLN_abd,length(CSLN_abd$vr))) %in% speciesMP$Taxon_SNa))

# dev.print(device = png, file = "CSLN_TPA.png", width = 1000, height=600) # If save of graph
plot(CSLN_abd,xlab="Taxon",ylab="Abond rel", dpos=c(40,100),
     main=paste("Methode TPA f=",CSLN_abd$f,sep=""))
# dev.off()

# CSLN_abd$n <- identify(CSLN_abd) # Fin du plateau
CSLN_abd$n <- max(88,minSpecies) # shortcut
CSLN_tpa_Taxon <- colnames(extract(CSLN_abd,CSLN_abd$n))
CSLN_cont_tpa <- as.matrix(extract(CSLN_abd,CSLN_abd$n))
CSLN_cont_tpa <- subset(CSLN_cont_tpa,rowSums(CSLN_cont_tpa)!=0)
CSLN_cont_tpa_names <- data.frame(Names = row.names(CSLN_cont_tpa)) %>%
  separate(Names,c("Zone","Tidal_Level","Period","Annee"),sep = "_",remove = FALSE) %>%
  unite("ZP", Zone, Period, sep = "_", remove = FALSE) %>%
  unite("ZA", Zone, Annee, sep = "_", remove = FALSE) %>%
  unite("PAZ", Period, Annee, Zone, sep = "_", remove = FALSE)

# DELETION OF RARE SPECIES IN THE COMPLETE DATABASE -----
CSLN_mud_tpa <- CSLN_mud_l[CSLN_mud_l$Taxon_SNa %in% CSLN_tpa_Taxon,]

```

## PERMANOVA

Permanova, a permutation multivariate anova, is used to determine whether there is a difference between the station-year pairs. This statistical test compares more than two variables in the same way as an Anova, but using a permutation of the data. The post-hoc pairwise test is used to find out which stations and/or years have a significant difference. The average contingency table per area reduced by TPA allows the establishment of a dissimilarity matrix by the Bray-Curtis method, which measures the differences between factor1-factor2 pairs according to the taxa found there.

If Pr (p-value) is : Signif. codes: 0 '\*\*\*' 0.001 '\*\*' 0.01 '\*' 0.05 '.' 0.1 ' ' 1

the factor variations explain R\^2 % of the dissimilarities

#### ADONIS and PAIRWISE ADONIS - ZONE

```{r}
#| label: calculation_5

CSLN_mat <- CSLN_cont_tpa; CSLN_name <- CSLN_cont_tpa_names # Choice either on tpa of complete data set
# # # WARNING FOLLOWING OPERATION CAN LAST VERY VERY LONG
ad <- adonis2(CSLN_mat~CSLN_name$Zone*CSLN_name$Period,method="bray") #*CSLN_cont_name$Annee
CSLN_adonis <- as.data.frame(cbind(test=row.names(ad),ad))
padZ <- pairwise.adonis(CSLN_mat,CSLN_name$Zone)
padP <- pairwise.adonis(CSLN_mat,CSLN_name$Period)
# padA <- pairwise.adonis(CSLN_mat,CSLN_name$Annee)
padZP <- pairwise.adonis(CSLN_mat,CSLN_name$ZP)
# padZA <- pairwise.adonis(CSLN_mat,CSLN_name$ZA)
# padZPA <- pairwise.adonis(CSLN_mat,CSLN_name$ZPA)
CSLN_pairado <- as.data.frame(rbind(padZ,padP,padZP)) #,padZA,padZPA
CSLN_pairado <- CSLN_pairado %>% filter(sig != "") # Keep only significant pairs


# # # SAVE BECAUSE SO LONG TO CALCULATE
# save(ad,CSLN_adonis,CSLN_pairado,file = paste(wdwork,"CSLN_Zone_Ado.RData", sep=""))

# load(paste(wdwork,"CSLN_Zone_Ado.RData", sep=""))

```

## ANALYSE DES COMMUNAUTES

Hierarchical Ascending Classification (HAC or dendrogram) constructed with the UPGMA agglomeration method to define 'clustchoix' groups at an equal cut-off level

```{r}
#| label: calculation_6

CSLN_simp <- CSLN_mud_l %>% #CSLN_mud_l or CSLN_mud_tpa
  select(Zone,Period,Taxon_SNa,Density_indm2) %>% # ,Tidal_level
  complete(nesting(Zone,Period),nesting(Taxon_SNa), # ,Tidal_level
           fill=list(Density_indm2=0)) %>%
  group_by(Zone,Period,Taxon_SNa) %>% # ,Tidal_level
  summarise(Density_m_=mean(Density_indm2,na.rm=TRUE)) %>%
  pivot_wider(names_from = Taxon_SNa, values_from = Density_m_, values_fill = 0) %>%
  unite("code",Zone,Period,sep = "_",remove = TRUE) # ,Tidal_level
CSLN_simp_mat <- as.matrix(CSLN_simp[,-1])
row.names(CSLN_simp_mat) <- CSLN_simp$code
CSLN_simp_mat <- subset(CSLN_simp_mat,rowSums(CSLN_simp_mat)!=0)
CSLN_simp_names <- data.frame(code=row.names(CSLN_simp_mat))  %>%
  separate(code, c("Zone", "Period"), sep = "_",remove = TRUE) %>% # ,"Tidal_level"
  unite("ZP",Zone,Period,sep = "_",remove = FALSE) # ,Tidal_level
# CSLN_simp_mat <- CSLN_cont_tpa # CSLN_cont_mat # 
# CSLN_simp_names <- CSLN_cont_tpa_names # CSLN_cont_mat_names # 
# any(is.nan(CSLN_simp))

# SIMPROF Determination of significantly different groups
CSLN_simprof <- simprof(CSLN_simp_mat, num.expected=1000, num.simulated=999,
                      method.cluster="average",method.distance="braycurtis") # summary(CSLN_simprof)
# groupe.clust <- cutree(CSLN_simprof$hclust, CSLN_simprof$numgroups)
# groupesdend <- as.data.frame(cbind(code=row.names(as.data.frame(groupe.clust)),Groupe_Simprof=groupe.clust))
groupesdend <- CSLN_simprof$significantcluster %>% 
  set_names(seq_along(.)) %>% enframe %>% unnest(cols=c(value)) %>%
  rename(Groupe_Simprof=name, code=value) %>% 
  mutate(Groupe_Simprof = parse_integer(Groupe_Simprof))
groupe.clust <- groupesdend$Groupe_Simprof; names(groupe.clust) <- groupesdend$code
simprof.plot(CSLN_simprof)
CSLN_sm  <- CSLN_sm %>%
  unite(ZP,Zone,Period,sep="_",remove = FALSE) %>%
  left_join(groupesdend, by=c("ZP"="code")) %>%
  relocate(Groupe_Simprof, .before="SR")
CSLN_sm$Groupe_Simprof <- as.factor(CSLN_sm$Groupe_Simprof)

col_Period <- colZiss(CSLN_unique$Period)[factor(CSLN_simp_names$Period)]
col_Zone <- colZiss(length(unique(CSLN_simp_names$Zone)))[factor(CSLN_simp_names$Zone)]
ggd1 <- CSLN_simprof$hclust %>% as.dendrogram %>% ladderize
ggd1 <- ggd1 %>% set("branches_k_color", k=CSLN_simprof$numgroups,value=colDarj(CSLN_simprof$numgroups)) %>% #
          set("branches_lwd", .8) %>%
          set("labels_col", col_Zone[order.dendrogram(ggd1)]) %>%
          set("labels_cex", .6) %>%
          # set("hang_leaves", 1) %>%
          set("leaves_pch", 19) %>%
          set("leaves_col", col_Period[order.dendrogram(ggd1)])
ggd1 <- as.ggdend(ggd1)
ggd1 <- ggplot(ggd1, horiz = TRUE, labels = TRUE)
ggd1 <- ggd1 + ggtitle("Simprof on mudflats")
print(ggd1)
ggsave(paste(wdgraph,"CSLN_Simprof_Zone",".png",sep=""), plot = ggd1, width = 12, height = 8)

# Significance of the groups
ad_CAH <- adonis2(CSLN_simp_mat~groupe.clust,method="bray"); ad_CAH
pad_CAH <- pairwise.adonis(CSLN_simp_mat,groupe.clust); pad_CAH

```

## INDVAL

For the characteristic taxa of each of these groups, the Indval has been calculated (Species Indicator Values). This index combines the relative abundance of each speciesMP and its occurrence in the samples to define an index between 0 and 1. The higher the IndVal, the more characteristic the speciesMP is of the community structure of the group.

```{r}
#| label: calculation_7

CSLN_cont_indval_mat <- CSLN_simp_mat # CSLN_cont_mat # CSLN_cont_tpa # 
CSLN_cont_indval_mat <- subset(CSLN_cont_indval_mat,select=colSums(CSLN_cont_indval_mat)!=0)
indval_mat <- indval(CSLN_cont_indval_mat,groupe.clust)
indvalresults <- data.frame(cbind(group=indval_mat$maxcls,
                                  indval=round(indval_mat$indcls,2),
                                  pvalue=round(indval_mat$pval,3)))
indvalresults <- cbind(sp=row.names(indvalresults),indvalresults)[order(indvalresults$group, indvalresults$pvalue, -indvalresults$indval),]
CSLN_indval_10 <- indvalresults %>% group_by(group) %>% arrange(group) %>% slice(1:10) %>%
  pivot_wider(names_from = group, values_from = indval)

# IndVal list reduced to significant speciesMP
alpha=0.05 #0.05
gr <- indval_mat$maxcls[indval_mat$pval<=alpha]
iv <- indval_mat$indcls[indval_mat$pval<=alpha]
pv <- indval_mat$pval[indval_mat$pval<=alpha]
# fr <- apply(CSLN_cont_CAH[,-1]>0, 2, sum)[indval_mat$pval<=alpha]
indvalsummary <- data.frame(group=gr, indval=round(iv,2), pvalue=round(pv,3)) #, freq=fr
indvalsummary <- cbind(sp=row.names(indvalsummary),indvalsummary)[order(indvalsummary$group, -indvalsummary$indval),]
indres <- as.data.frame(indval_mat$indcls)
indres <- cbind(sp=row.names(indres),indres)

# save.image(file = paste(wdwork,"CSLN_BDD_Zone",".RData", sep=""))

```

## nMDS

An non-metric MultiDimensional Scaling represents the distances between elements in a two-dimensional space. It is an iterative process of positioning the data on a plane to best approximate the dissimilarity matrix. The calculated stress is the indicator of the difference between the representation on the plane and the matrix. It should be at most 0.2, ideally less than 0.1, in order to reflect ecological and/or hydroclimatic factors.

```{r}
#| label: calculation_8

CSLN_cont_nMDS_mat <- CSLN_simp_mat # CSLN_cont_tpa # CSLN_cont_mat # 

CSLN_mds <- metaMDS(CSLN_cont_nMDS_mat,distance = "bray", k = 2,try = 1000, autotransform =FALSE)
sc <- scores(CSLN_mds)
CSLN_mds_dat <- data.frame(scores(CSLN_mds)$sites) %>% # Using the scores function from vegan to extract the code scores
                    mutate(code=row.names(scores(CSLN_mds)$sites)) %>% relocate(code) %>%
                    left_join(groupesdend, by="code") %>%
                    separate(code, c("Zone", "Period"), sep = "_",remove = FALSE) %>% # ,"Annee"
                    unite(ZP,Zone,Period, sep = "_",remove = FALSE) %>%
                    group_by(Groupe_Simprof) %>% # Zone,Tidal_level,Period
                    mutate(NMDS1.m = mean(NMDS1, na.rm = TRUE),
                           NMDS2.m = mean(NMDS2, na.rm = TRUE))

CSLN_mds_dat$Groupe_Simprof <- as.factor(CSLN_mds_dat$Groupe_Simprof)
rownames(CSLN_mds_dat) <- c()
CSLN_mds_mean <- CSLN_mds_dat %>% 
  unite("ZP",Zone,Period, sep = "_",remove = FALSE) %>%
  group_by(ZP) %>% 
  summarise(NMDS1.m = mean(NMDS1, na.rm = TRUE),
            NMDS2.m = mean(NMDS2, na.rm = TRUE))
CSLN_mds_species <- as.data.frame(CSLN_mds$species)
CSLN_mds_species <- cbind(sp=rownames(CSLN_mds_species),CSLN_mds_species)  # create a column of speciesMP, from the rownames of CSLN_mds_species

nbA = length(unique(CSLN_mds_dat$Zone)) # dim(CSLN_mds_mean)[1]
nbB = length(unique(CSLN_mds_dat$Period))
palette=colZiss # colDarj colZiss colSpec
bp <- ggplot(data=CSLN_mds_dat) +
# Add speciesMP name
    # geom_point(data=CSLN_mds_species,aes(x=MDS1,y=MDS2),shape=8,size=1,colour="gray50") + # add the point markers
    geom_text(data=CSLN_mds_species,aes(x=MDS1,y=MDS2,label=sp),
              size=2.5,colour="gray50",check_overlap = TRUE, fontface = "italic") +
# Base scatter plot 
    geom_point(aes(x=NMDS1,y=NMDS2,shape=Period,colour=Zone),size=3) +
    # geom_text(aes(x=NMDS1,y=NMDS2,colour=Zone,label=Period),size=2.5,hjust=-0.3, fontface = "plain") +  # add the site labels
    scale_colour_manual(values=palette(nbB)) +
    stat_ellipse(aes(x=NMDS1,y=NMDS2,group=Groupe_Simprof), #,linetype = groupe.clust,color=groupe.clust
                 type = "norm",level = 0.9,linetype = 3,show.legend = FALSE) + #
# Lines to connect the same Zone and label it
    geom_segment(aes(x=NMDS1.m, y=NMDS2.m, xend=NMDS1, yend=NMDS2), #, linetype = Period
                 linewidth=.1,color="grey") +
    # annotate(geom="label",x=CSLN_mds_mean$NMDS1.m,y=CSLN_mds_mean$NMDS2.m,label=CSLN_mds_mean$Zone,
    #          fill=palette(nbB),alpha=0.4) +
# Graphic visuals
    annotate("text",x=min(CSLN_mds_dat$NMDS1),y=min(CSLN_mds_dat$NMDS2),hjust=-1,
             label=paste("Stress =",round(CSLN_mds$stress,4)), size = 4)+
    ggtitle(label="nMDS CSLN_mud_l data by Station_originelle")+
    theme(axis.text.x = element_blank(),  # remove x-axis text
          axis.text.y = element_blank(), # remove y-axis text
          axis.ticks = element_blank()) #+theme_bw()
print(bp)
ggsave(paste(wdgraph,"nMDS Macrofaune by Zone",".png",sep=""), plot = bp, width = 12, height = 8, dpi=600)

```

#### ANALYSES STATISTIQUES

```{r}
#| label: calculation_9

# CSLN_stats <- data.frame(matrix(NA,ncol = 10, nrow = length(anneesData))) #NULL
# colnames(CSLN_stats) <- c("Categorie","Variable","Annee","Mois","Shapiro","A","B","C","D","Kruskal") #NULL
# k=1
# for (j in 1:length(anneesBiv)){
  # df <- with(CSLN_summary,CSLN_summary[Annee==anneesBiv[j],])
  # shap <- by(df$Densite.m2.mea,df$Zone,shapiro.test)#Si p>alpha normalite
#   krus <- kruskal.test(Densite.m2.mea~as.factor(Zone),data=df)#Si p<alpha diff entre groupes
#   CSLN_mud_l.zone.stat.s[k,] <- c("CSLN_mud_l","Densite",as.character(anneesData[j]),"Mois","Shapiro",
#                           round(shap$A$p.value,4),round(shap$B$p.value,4),
#                           round(shap$C$p.value,4),round(shap$D$p.value,4),round(krus$p.value,4))
#   k <- k+1
# }
# #glob <- pairwise.wilcox.test(df$Densite.m2,df$Zone,p.adj="bonf")

```

# Final actions and save

Rdata are saved in `rdataout`. An excel file collects data in `r binderout` , with sheets for :

-   data : contains whatever

```{r}
#| label: finalsave
#| eval: false
wb <- copyWorkbook(loadWorkbook(binderin))
if (!("AllMeas" %in% names(wb))) {addWorksheet(wb=wb, sheetName = "AllMeas")}
writeData(wb, sheet = "AllMeas", x = data, startCol = 1, startRow = 1,withFilter = FALSE)
saveWorkbook(wb,file=binderout, overwrite = TRUE)

save.image(file = rdataout)
beepr::beep(2)
```

```{r}
#| label: finalsave_r
#| eval: false

save.image(file = rdataout)
beepr::beep(2)
```

# References {.unnumbered}

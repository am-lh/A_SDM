---
title: "MELTING POTES PROJECT : SDM-NEO MODELS non Linear Quantile Regression"
author: "Am√©lie Lehuen"
description: "ANALYSIS WITH KOENKER'S QUANTREG PACKAGE"
date: "`r format(Sys.time(), '%B %Y')`"
editor: source
execute:
  eval: true
  echo: false
  message: false
  warning: false
  output: true
  include: false
editor_options: 
  chunk_output_type: console
---

# NON LINEAR QUANTILE REGRESSION ANALYSIS WITH KOENKER'S QUANTREG PACKAGE

## Introduction

Non linear quantile regression analysis with Koenker's `quantreg` package

<!-- ## Script preparation -->

### Packages

```{r}
#| label: load-packages
#| code-summary: "Packages"
library(conflicted)
library(readxl) ; library(openxlsx); library(beepr) # Edition d'un fichier Excel
library(tidyverse); library(reshape2); library(rlist) # the one; melt; list.append
library(data.table)
library(rstatix); library(Hmisc)  # corr and pvalue calculation

library(ggpubr); #library(GGally); # stat_compare_means ;
library(scales); library(RColorBrewer); library(wesanderson); library(grafify); library(colorspace); library(ggsci)# show_col and colors colors colors!
library(quantreg);# library(visreg)
library(plotly); library(plot3D);  # graphiques 3D plot 3D for mesh library(pracma)
library(patchwork)
library(ggridges)
# GIS Packages
library(sf); library(sfheaders); # st_as_sf ; sf_to_df
library(tmap); library(tmaptools)
library(htmlwidgets) # library(leaflet) # saveWidget ; for interactive maps
library(introdataviz) # geom_split_violin # devtools::install_github("psyteachr/introdataviz")

conflict_prefer("transpose", "purrr")
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("summarise", "dplyr")
conflict_prefer("melt", "reshape2")
conflict_prefer("layout", "plotly")

```

### Working Environment

```{r}
#| label: workenvir

rm(list=ls())
wdmat <- "Matrices/"
wdgraph <- "C:/Users/lehuen201/Back Up AMLH/Melting Potes/BDD/A_SDM_NEO/Plots/" #"Plots/"
wdres <- "Results/"
pc <- "C:/Users/lehuen201/Nextcloud/" # "E:/" #
wdGIS <- paste(pc,"Melting Pot/SIG/",sep="")

```

### Graphic charter

```{r}
#| label: graphchart

theme_set(theme_bw(base_size = 14)) # theme_gray() theme_bw() theme_light()

pal_cspx <- function(x) {divergingx_hcl(x,palette = "Zissou 1")}; # show_col(pal_cspx(6)) # colorspace
colRQ<-pal_cspx(4); colBin<-c(pal_cspx(6)[3],pal_cspx(6)[5]); blank<-alpha("#dae8ed",0.1); # show_col(colRQ)
Scalc_rq<- function() {scale_colour_manual(values=colRQ)}
Scalf_rq2d <- function() {scale_fill_gradientn(colours=colRQ)} # function(x) {scale_fill_material("teal")} # 
Scale_brew <- function()
  {scale_colour_brewer(palette="Spectral",aesthetics=c("colour","fill"))}
Scale_co <- function() 
  {scale_colour_manual(palette=colorRampPalette(brewer.pal(11, "Spectral")))}
Scale_fi <- function() 
  {scale_fill_manual(palette=colorRampPalette(brewer.pal(11, "Spectral")))}

pal_ggscc <- pal_material("teal"); # show_col(pal_ggscc(9)) # ggsci
colSum <- c(pal_ggscc(9)[3],pal_ggscc(9)[7],pal_ggscc(9)[1]) # show_col(colSum)
colInliers<-pal_material("teal")(10)[5] ; colOutliers = pal_material("deep-orange")(10)[5] # show_col(colOutliers)
Scalc_misc <- function() {scale_color_discrete_diverging(palette = "Blue-Red 3")}
Scale_map<- function() {scale_fill_distiller(palette = "Spectral")}
```

### Home made functions

```{r}
#| label: functmade

gaussf <- function(x,A,mu,sigma) {
  A*exp(-((x-mu)^2/(2*sigma^2))/(sigma*sqrt(2*pi)))}
gauss2d <- function(x1,x2,A,mu1,sigma1,mu2,sigma2) {
  A*exp(-(((x1-mu1)^2/(2*sigma1^2))+((x2-mu2)^2/(2*sigma2^2))))}

AICc<-function(modelq,smrq){ 
    df<-dim(smrq$coefficients)[1]-1
    aicc<-AIC(modelq)+2*df*(df+1)/(length(modelq$y)-df-1) 
    return(aicc) 
  } 
```

## Load of External data and Basic Variables

### External data

```{r}
#| label: externdata

rdatain <- sprintf("%sCSLN_Mars_BDD.RData",wdmat)
load(rdatain)
```

### Output save binder and Rdata

```{r}
#| label: outfiles

binderout <- sprintf("%sCSLN_BDD.xlsx",wdres)
rdataout  <- sprintf("%sCSLN_Mars_RQnli_BDD",wdmat)
# if exists
load(paste0(rdataout,".RData"))
```

### Basic variables

```{r}
#| label: basicvar

etude <- "CSLN_Mars"
espece <- "CERED"
analysis <- "RQ Nonlinear"
sp <- which(speciesMP$SPCourt == espece)
sai <- which(saison$M_Def == "Year") #Year Winter Summer

# Var_choosen<-c("flow_mxd","inunt","sal_dtd","temp_m","mudrate_m","tenfon_mxd")
# Mod_chosen<-list(c("flow_mxd","inunt"),
#                   c("mudrate_m","tenfon_mxd"),
#                   c("sal_dtd","temp_m"),
#                   c("inunt","temp_m"))
# taus <- c(0.5,0.9,0.95,0.975) # c(0.5,0.85,0.9,0.95,0.975,0.99) #c(1:19/20,0.975,0.99)
# taus_l<-setNames(as.list(taus),sprintf("%0.3f",taus))
type<-list(nli= c("*","nli"))
tauchoice<-0.975
graphfine<-50 # graph resolution for 2D and 3D graphs surfaces

# Model equation tested ----
# Gaussian equation one factor with Initial conditions (CI) vector
# FactA_CI <- c(0.99,0.99,0.99,0.99,0.99,0.99) #(0.99, bathy) modif facteur A regarding results of RQ, same length as pred_red
# SDM_tau1<-c(0.975,0.975,0.975,0.975,0.95,0.975);
# Gaussian equation two factors with Initial conditions (CI) vector
FactA_CI <- FactA_CI2d <- 0.99

# reponse<-reponse %>%
#   filter(rvar %in% c("Biomass_gAFDWm2","Density_indm2")) %>%
#   rowid_to_column("id") %>% 
#   mutate(whole=sprintf("%s (%s)",rdescr,runit)) %>% 
#   as.list %>% 
#   transpose(.) %>% 
#   setNames(c("Biomass","Density"))
# pred_red <- predict %>% 
#   subset(Var %in% Var_choosen) %>% 
#   arrange(match(Var,Var_choosen)) %>%
#   rowid_to_column("id") %>%
#   mutate(whole=sprintf("%s (%s)",Desc,Unit)) %>% 
#   as.list

# pred_red_comb<-map(as.list(c(1:2)), \(idx)
#   {map(pred_red,
#       ~combn(.,idx, simplify = FALSE)) %>% transpose(.)}  ) %>% 
#   setNames(paste0("x",1:2))
# 
# pred_red_comb<-map2(pred_red_comb,
#                     map_depth(pred_red_comb,2,
#                               ~paste0(.x$id,collapse="")),
#                     ~setNames(.x,.y ) )
# 
# pred_red_comb_sel<-map(pred_red_comb,
#       ~map(Mod_chosen, \(mod) keep(.x,~identical(.x$Var, mod)) ) ) %>% 
#   map(., compact) %>% compact %>% 
#   map(.,list_flatten) %>% 
#   list_flatten(.,name_spec= "{inner}")

df <- CSLN_Mars[which(CSLN_Mars$SPCourt == espece),]

Mars_SDM<-Mars_dat_sf %>% 
  select(c(NINJ,Lon,Lat,Zone,Tidal_level,Period,Annee,pred_red$Var))
```

# SDM Model calculation
## RQ calculation
```{r}
#| label: rq_Mod_calc

rq_nLin <- function(sdmod,df,biolo,typ,taus) {
    # biolo=reponse[[1]]; typ=type[[1]]
    # sdmod=pred_red_comb[[1]][[2]]
  typetxt<-paste0("RQ",length(sdmod$id),typ[2])
  sdmname<-sprintf("%s_%g%g%g%s%s",typetxt,sp,sai,
                   biolo$id,
                   paste0(sdmod$id,collapse = ""),
                   ifelse(length(sdmod$id)==1,"0","") )
  
  yt<- biolo$rvar
  yl<- biolo$whole
  xt<-paste(sdmod$Var, collapse=typ[1])
  xl<-paste(sdmod$whole, collapse=paste0(" ",typ[1]," "))
  dfrq <-df[,c(yt,sdmod$Var)] %>% 
    drop_na() %>%
    setnames(old=c(yt,sdmod$Var),
             new=c("y",paste0("x",1:length(sdmod$Var))) ) %>% 
    mutate(across(everything(),jitter))
  formumod<-as.formula(ifelse(length(sdmod$id)==1,"y~gaussf(x1,A,mu,sigma)",
                                                  "y~gauss2d(x1,x2,A,mu1,sigma1,mu2,sigma2)"))
  
  lci <- if(length(sdmod$id)==1){
                list(A=quantile(dfrq$y,FactA_CI), mu=median(dfrq$x1), sigma=sd(dfrq$x1))
            } else {
                list(A=quantile(dfrq$y,FactA_CI), mu1=median(dfrq$x1), sigma1=sd(dfrq$x1),
                                                  mu2=median(dfrq$x2), sigma2=sd(dfrq$x2))}

  
  # Model grid definition
  xmod<-map( #x1x2mod
            map(as.list(names(dfrq %>% select(-y))),
                ~{ dfrq %>% select(-y) %>% 
                  summarise(across(everything(),
                                   list(~min(.x, na.rm = TRUE), ~max(.x, na.rm = TRUE)),
                                   .names = "{.fn}.{.col}")) %>% 
                  select(contains(.x)) %>% 
                  unlist(., use.names=FALSE) } ) %>% 
              setNames(names(dfrq %>% select(-y))) ,
            ~seq(.[1],.[2],length.out=graphfine) ) %>% 
        bind_cols()
  gridx <- expand.grid(xmod)
  if(length(sdmod$Var)==2){
    gridxmat <- mesh(xmod$x1,xmod$x2)
    } else{ gridxmat<-NULL }
  mod_grid<-list(xmod=xmod,gridx=gridx,gridxmat=gridxmat)
  # Zinit<-gauss2d(x1=gridxmat[["x"]],
  #              x2=gridxmat[["y"]],
  #              A=lci[[1]],mu1=lci[[2]],
  #              sigma1=lci[[3]],mu2=lci[[4]],
  #              sigma2=lci[[5]])

  modt<-map(as.list(taus), \(taut) { #taut=taus[[4]]
    modl<-list()
    tryCatch({
      # nlRQ PARAMETER CONTROL TO AVOID R ABORT WHEN SUMMARY(MODEL) : InitialStepSize=0 (ex=1)
      cc<-nlrq.control(maxiter=100, k=2, 
                       InitialStepSize = 0, 
                       big=1e+20, eps=1e-06, beta=0.97)
      modelq0<-rq(y ~ 1, data=dfrq, tau=taut)
      modelq<-nlrq(formumod, data=dfrq, 
                   start = lci, tau=taut,
                   control=cc, method="L-BFGS-B")
      smrq <- summary(modelq)  #, se="boot"
      meta <- list(type=typ[1],typetxt=typetxt,
             Sp=espece,Season=saison[sai,2],
             reponse=yt,reponset=yl,
             unit=biolo$runit,
             predict=xt,predictt=xl,
             predictl=sdmod$whole,
             predfile=paste(sdmod$Var, collapse="_"),
             lci=lci)
      valid <- list(AICc=round(AICc(modelq,smrq),1),
                    Rone=round((1 - modelq$m$rho/modelq0$rho),5))    
      smrq_t <- smrq$coefficients %>% 
                as.data.frame %>%
                  mutate(Var=rownames(.)) %>%
                  relocate(Var) %>%
                  remove_rownames(.) %>%
                  mutate(tau=taut, taust=sprintf("tau= %s",tau),
                         sdmname=sdmname,
                         formula=paste0(format(formumod),collapse=""), #format(modelq$formula),
                         type=typ[1],typetxt=typetxt,
                         Sp=espece, Season=saison[sai,2],
                         reponse=yt, reponset=yl, unit=biolo$runit,
                         # Predictor1=pred_red[k,1], Predictor2=pred_red[k2,1],
                         predict=xt, predictt=xl,
                         predfile=paste(sdmod$Var, collapse="_"))
      smrq_t<-smrq_t %>% append(valid)
      # Out of limits points calculation
      rqlim_t <- modelq %>% 
        predict %>% 
        as.data.frame %>%
        rename_all(~sprintf("%s",taut)) %>% 
        mutate(across(everything(), function(x){replace(x, which(x<0), NA)})) %>% 
        bind_cols(tibble(dfrq)) %>% 
        melt(id.vars=names(dfrq),
                      variable.name = "tau",value.name = "RqLim") %>% 
        mutate(sdmname=sdmname,
               taust=sprintf("tau= %s",tau),
               tau=as.numeric(as.character(tau))) %>% 
        mutate(status=case_when(y>RqLim ~"over",y<=RqLim ~"under" ))
      # Surface model calculation
      mod_pred_t <- as.data.frame(predict(modelq,newdata=gridx)) %>%
        rename_all(~sprintf("%s",taut)) %>% 
        mutate(across(everything(), 
                      function(x){replace(x, which(x<0), NA)})) %>% 
        bind_cols(gridx) 
      mod_pred_t <- mod_pred_t %>% 
        rename_all(~c("RqMod",names(dfrq %>% select(-y))) ) %>% 
        mutate(sdmname=sdmname,
               tau=taut,
               taust=sprintf("tau= %s",tau))
      
    modl<-list(sdmname=sdmname, meta=meta,
                modelq=modelq, smrq=smrq, smrq_t=smrq_t,
                rqlim_t=rqlim_t, mod_grid=mod_grid, mod_pred_t=mod_pred_t)
    },error = function(e) {print(e)})#,finally = {}) # end try catch
  } ) # end map taus
  
  modt <- modt %>%
    setNames(sprintf("%.3f",taus)) %>% 
    transpose %>% 
    modify_at(.,c("sdmname","meta","mod_grid"),~.x[[1]]) %>% 
    modify_at(.,c("smrq_t","rqlim_t","mod_pred_t"),~.x %>% bind_rows())
  return(modt)
} # end func

rq_Mod_all <-
  map( reponse, \(biolo)
    {map( type, \(typ)
      {map_depth( pred_red_comb,2,
            ~rq_nLin(.x,df,biolo,typ,taus)) } ) } ) %>%
  map_depth(.,3, ~setNames(.x,map(.x,~.$sdmname)) ) %>% # SDM names to list of results
  map_depth(.,2,~list_flatten(.x,name_spec= "{inner}")) %>% # remove x1/x2 level
  map(.,~list_flatten(.x,name_spec= "{inner}")) %>%  # remove typ level
  map_depth(.,3,compact) # suppress trycatch errors

rq_Mod_sel<-map(rq_Mod_all,
      ~keep_at(.,~ grepl(paste0(names(pred_red_comb_sel),"$",collapse="|"),
                         .x)) ) # collect all mod in selection
```

## Mars calculation of models
```{r}
#| label: rq_Mod_mars

rq_Mod_mars <- function(rqMod,MarsSDM,taus) {
    # biolo=reponse[[1]]; MarsSDM=Mars_SDM
    # rqMod=rq_Mod_sel[[biolo$rdescr]][[2]]
  typetxt<-rqMod$meta$typetxt
  vars<-unlist(strsplit(rqMod$meta$predict,rqMod$meta$type,fixed = TRUE))
  taurel<-names(rqMod$modelq)
  xmars <- MarsSDM %>% 
    st_drop_geometry() %>% # as.data.frame() %>% 
    select(all_of(vars)) %>% 
    rename_all(~paste0("x",1:length(vars)))

  MarsSDM<-MarsSDM %>% 
    select(NINJ,Lon,Lat,Zone,Tidal_level,Period,Annee,vars)

  RqModMars <- as.data.frame(map(rqMod$modelq,
    ~predict(.x,,newdata=xmars) )) %>%
    rename_all(~sprintf("t%s",taurel)) %>% 
    mutate(across(everything(), function(x){replace(x, which(x<0), NA)}))

  MarsSDM<-MarsSDM %>% cbind(RqModMars)
  return(MarsSDM)
}

rq_Mod_mars_all<-
  map_depth(rq_Mod_all,2,
            ~rq_Mod_mars(.x,Mars_SDM,taus))

rq_Mod_mars_sel<-
  map_depth(rq_Mod_sel,2,
            ~rq_Mod_mars(.x,Mars_SDM,taus))

```

Summary of values by period for mapping (!! can be very long)
```{r}
rq_Mod_mars_sel_per<-
  map_depth(rq_Mod_mars_sel,2,
            ~{ .x %>% 
               group_by(NINJ,Period) %>% 
               summarise(across(is.numeric,~mean(.x,na.rm=TRUE))) } )

save(list=(ls()[grep("rq_", ls())]),
     file = paste0(rdataout,".RData"))
```


# Model graphs
```{r}

wdgraph <- "C:/Users/lehuen201/Back Up AMLH/Melting Potes/BDD/A_SDM_NEO/Plots/" #"Plots/"
graph_path <- sprintf("%s%s/%s/",wdgraph,espece,analysis)
titleG <- sprintf("%s %s in %s",
                  analysis,speciesMP$Taxon_SNa[sp],saison[sai,2])
```

## Summaries graphs
Pas les RQ1 pk?
```{r}
#| label: rq_Mod_plot_sum

pl_rq_Mod_sum<-function(rqMod,titleG){
    # rqMod=rq_Mod_sel[[1]][[1]]
  rqMod$smrq_t$lowerbd<- rqMod$smrq_t$Value-rqMod$smrq_t$`Std. Error`
  rqMod$smrq_t$upperbd<- rqMod$smrq_t$Value+rqMod$smrq_t$`Std. Error`
  ggplot(rqMod$smrq_t,aes(x=tau,y=Value, group = 1)) +
    geom_ribbon(aes(ymin=lowerbd, ymax=upperbd), 
                fill=colSum[3], alpha=0.8) +
    geom_point(col=colSum[2],size=1) +
    geom_line(col=colSum[2],linewidth=.5, alpha=0.8) +
    facet_wrap(~Var,scales="free") +
    labs(title = titleG,subtitle = titleG)
 }

# pl_rq_all_sum<-
#   map_depth(rq_Mod_all,2,
#             ~pl_rq_Mod_sum(.x,titleG))

pl_rq_sel_sum<-
  map_depth(rq_Mod_sel,2,
            ~pl_rq_Mod_sum(.x,titleG))

walk(pl_rq_sel_sum,
  ~{iwalk(., ~ggsave(sprintf("%s/%s/%s_%s_sm.tiff",
                    graph_path, substr(.y,1,6), espece, .y),
                    plot = .x,
                    width = 10, height = 7, dpi=400) ) } )
```

## AIC plot
```{r}
#| label: rq_Mod_plot_aic

pl_rq_Mod_aic<-function(smrql,titleG){
# smrql <- rq_Mod_x1 %>%
#   map_depth(.,2, ~map_dfr(.$smrq_t, ~.) ) %>%
#   map(., ~map_dfr(., ~.) ) %>%
#   map_dfr(., ~.)
  smrql %>%
    group_by(tau) %>%
    ggplot(aes(x=reorder(predict,-Delta_AICc),
               y=Delta_AICc,
               color = factor(tau),shape=reponse))+
    geom_point(alpha=0.8, size= 5) +
    scale_color_manual(values=colRQ) +
    labs(title=paste("Delta AICc scores for ",titleG,sep=""),
         x="Model",y="Delta AICc",
         color="Quantile",shape="Biologic") +
    theme(axis.text = element_text(size=10,face="bold")) +
    coord_flip()
}

rq_Mod_sel_sm<-
  rq_Mod_sel %>% 
    map_depth(.,2, ~map_dfr(.$smrq_t, ~.) ) %>% 
    map(., ~map_dfr(., ~.) ) %>% 
    map_dfr(., ~.) %>% 
  mutate(Delta_AICc= AICc-min(AICc,na.rm=TRUE))

pl_rq_sel_aic<- rq_Mod_sel_sm %>%
  filter(!grepl(c("RQ3"),sdmname)) %>%
  pl_rq_Mod_aic(.,titleG)
ggsave(sprintf("%s%s_RQ_AIC_all_scores.tiff",
                 graph_path,espece),
         plot = pl_rq_sel_aic,
         width = 16, height = 8, dpi=400)

pl_rq_aic<-rq_Mod_sel_sm %>% 
  filter(!grepl(c("RQ3"),sdmname)) %>%
  mutate(nbvar=substr(typetxt,1,3)) %>% 
  group_by(tau) %>%
  ggplot(aes(x=reponse, #reorder(factors,-AICc),
             y=Delta_AICc,
             color = factor(tau),
             shape = type))+
  geom_point(size= 5) +
  facet_grid(nbvar~.) +
  scale_shape_manual(values=c(1, 8))+
  scale_color_manual(values=colRQ) +
  labs(#title=titleG, 
       x="Biologic",y="AIC",
       color="Quantile",shape="Type") +
  theme(axis.text = element_text(size=10,face="bold")) +
  coord_flip()
ggsave(sprintf("%s%s_RQ_AIC_scores.tiff",
                 graph_path,espece),
         plot = pl_rq_aic,
         width = 16, height = 8, dpi=400)

```

## Qqplots Residuals graphs
!!!!!patchwork a finir !!!!!
```{r}
#| label: rq_Mod_plot_res

pl_rq_Mod_res<-function(rqMod,titleG){
    # biolo=reponse[[1]]
    # rqMod=rq_Mod_sel[[biolo$rdescr]][[1]]
  rqResid <- melt(residuals(rqMod$modelq)) %>% 
    rename(tau=Var2, residuals=value) 
  subtitleG <- sprintf("%s vs %s",rqMod$meta$reponset,rqMod$meta$predictt)
  ggplot(rqResid, aes(sample=residuals, color=tau)) + 
    stat_qq() + stat_qq_line() + 
    facet_wrap(~tau) +
    Scalc_rq() +
    theme(legend.position="bottom")+
    labs(title=paste("Residuals for ",titleG,sep=""),
         subtitle=subtitleG,
         color="Quantile")
}

# pl_rq_all_res<-
#   map(reponse, \(biolo)
#     {map(rq_Mod_all[[biolo$rdescr]],
#          ~pl_rq_Mod_res(.x,titleG)) } )

# pl_rq_all_resb<-map(type, \(typ)
#     {map( map(pl_rq_all_res,
#               ~keep(.,str_detect(names(.), typ[2])) ),
#           ~{wrap_plots(., guides="collect") +
#               plot_annotation(title=titleG,tag_levels = c('A')) &
#               theme(title = element_blank(),
#                     legend.position = "none")   } ) } )

# pl_rq_sel_res<-
#   map(reponse, \(biolo)
#     {map(rq_Mod_sel[[biolo$rdescr]],
#          ~pl_rq_Mod_res(.x,titleG)) } )

# 
# pl_rq_sel_resb<-map(type, \(typ)
#     {map( map(pl_rq_sel_res,
#               ~keep(.,str_detect(names(.), typ[2])) ),
#           ~{wrap_plots(., guides="collect") +
#               plot_annotation(title=titleG,tag_levels = c('A')) &
#               theme(title = element_blank(),
#                     legend.position = "none")   } ) } )

# map(pl_rq_sel_resb,
#   ~{ggsave(sprintf("%s/residuals.tiff",
#                    graph_path),
#      plot = .x, width = 18, height = 12, dpi=400) } )

```

## Curves 1D sdm plots
make a patchwork to have all in one board
```{r}

pl_rq_Mod_1d<-function(rqMod,titleG){
    # biolo=reponse[[1]]
    # rqMod=rq_Mod_x1[[biolo$rdescr]][[1]]

  ggplot() +
    geom_line(data=rqMod$mod_pred_t, 
              aes(x=x1, y=RqMod, col=as.factor(tau))) +
    geom_point(data=rqMod$rqlim_t %>% 
                 filter(tau==max(.$tau,na.rm=TRUE)), 
               aes(x=x1, y=y,shape=status),
               alpha=0.5) +
    Scalc_rq() +
    scale_shape_manual(values=c(8, 21)) +
    guides(shape = "none") +
    theme(legend.position="bottom") +
    labs(title=titleG,
       color="Quantile", #shape="Type",
         x=rqMod$meta$predictt, y=rqMod$meta$reponset)
}

pl_rq_all_1d <- rq_Mod_all %>% 
    map(.,~keep_at(.x,grepl("0$",names(.x))) ) %>% 
    map_depth(.,2,~pl_rq_Mod_1d(.x,titleG) )
# walk(pl_rq_all_1d[1:2],
#   ~{iwalk(., ~ggsave(sprintf("%s/%s/%s_%s_1d.tiff",
#                     graph_path, substr(.y,1,6), espece, .y),
#                     plot = .x,
#                     width = 10, height = 7, dpi=400) ) } )

pl_rq_all_1d$all <- map(pl_rq_all_1d,
        ~{(wrap_plots(.) &
             labs(title=element_blank()) &
             theme(legend.position="bottom",
                   plot.title = element_text(hjust = 0.5)) ) +
          plot_layout(guides="collect") +
          plot_annotation(title=titleG) } )

walk(pl_rq_all_1d["all"],
  ~{iwalk(., ~ggsave(sprintf("%s/RQ1add/%s_%s_1d.tiff",
                    graph_path, espece, .y),
                    plot = .x,
                    width = 10, height = 7, dpi=400) ) } )

```

## Raster 2D sdm plots
```{r}
#| label: rq_Mod_plot_2d

pl_rq_Mod_2d<-function(rqMod,titleG){
    # biolo=reponse[[1]]
    # rqMod=rq_Mod_sel[[biolo$rdescr]][[1]]
  
  pl_2d<-list(all=NULL, one=NULL)

  pl_2d$all<-ggplot(rqMod$mod_pred_t) +
    geom_raster(aes(x = x1, y = x2, fill = RqMod),alpha=0.8) + 
    geom_point(data=rqMod$rqlim_t %>% filter(status=="under"),aes(x=x1, y=x2), 
               shape=21, size=1, color=colInliers, 
               fill=colInliers, alpha=.5, na.rm = TRUE) +
    geom_point(data=rqMod$rqlim_t %>% filter(status=="over"),aes(x=x1, y=x2), 
               shape=23, size=1, color=colOutliers, 
               fill=colOutliers, alpha=.5, na.rm = TRUE) +
    labs(title=titleG,
         x=rqMod$meta$predictl[1],
         y=rqMod$meta$predictl[2],
         fill = paste("SDM-NEO\n",rqMod$meta$unit,sep="")) +
    guides(alpha = "none") +
    Scalf_rq2d() +
    facet_wrap(taust ~ .)
  
    # Define surfaces for each tau
    pl_2d$one<- map(taus_l, ~{ #taut=taus_l[[1]]
      rqMod$mod_pred_t %>% 
        filter(tau==.x) %>% 
      ggplot() +
        geom_raster(aes(x = x1, y = x2, fill = RqMod),alpha=0.8) + 
        geom_point(data=rqMod$rqlim_t %>% filter(status=="under"),
                   aes(x=x1, y=x2), 
                   shape=21, size=1, color=colInliers, 
                   fill=colInliers, alpha=.5, na.rm = TRUE) +
        geom_point(data=rqMod$rqlim_t %>% filter(status=="over"),
                   aes(x=x1, y=x2), 
                   shape=23, size=1, color=colOutliers, 
                   fill=colOutliers, alpha=.5, na.rm = TRUE) +
        labs(title=sprintf("tau = %0.3f",.x),
             x=rqMod$meta$predictl[1],
             y=rqMod$meta$predictl[2],
             fill = paste("SDM-NEO\n",rqMod$meta$unit,sep="")) +
        guides(alpha = "none") +
        Scalf_rq2d()
      
    } ) # map taus
  return(pl_2d)
}

# pl_rq_all_2d<- rq_Mod_all %>% 
#     map(.,~keep_at(.x,grepl("^RQ2",names(.x))) ) %>% 
#     map_depth(.,2,~pl_rq_Mod_2d(.x,titleG) )

pl_rq_sel_2d<- rq_Mod_sel %>% 
    map(.,~keep_at(.x,grepl("^RQ2",names(.x))) ) %>% 
    map_depth(.,2,~pl_rq_Mod_2d(.x,titleG) )

walk(pl_rq_sel_2d,
   ~{iwalk(., ~ggsave(sprintf("%s/%s/%s_%s_2d.tiff",
              graph_path, substr(.y,1,6), espece, .y),
              plot = .x$all,
              width = 10, height = 7, dpi=400) ) } )

```

## Surfaces 3D sdm plots
```{r}
#| label: rq_Mod_plot_3d

pl_rq_Mod_3d<-function(rqMod,taus,titleG){
    # biolo=reponse[[1]]
    # rqMod=rq_Mod_sel[[biolo$rdescr]][[1]]
  
  yl<-rqMod$meta$reponset
  xl<-rqMod$meta$predictl
  myscene<-list(camera = list(eye = list(x = -1.5, y = 1.5, z = 0.3)),
                aspectmode='cube', # define standard layout scene
                xaxis = list(title = xl[1]), 
                yaxis = list(title = xl[2]), 
                zaxis = list(title = yl))
  pl_3d<-list(all=NULL, one=NULL)
  
  rqlim <- rqMod$rqlim_t %>% 
    filter(tau==taus[length(taus)])
  rqsup<-rqlim %>% filter(status=="over")
  rqinf<-rqlim %>% filter(status=="under")
  
  # Experimental points on 3D graphic and all surfaces
  pl_3d$all<-plot_ly(showlegend=FALSE) %>% 
      add_trace(x = rqsup$x1, y = rqsup$x2, z = rqsup$y, 
                mode = "markers", type = "scatter3d",
                marker = list(size = 3, color = colOutliers, 
                              opacity = 0.7, symbol = "diamond"))%>%
      add_trace(x = rqinf$x1, y = rqinf$x2, z = rqinf$y, 
                mode = "markers", type = "scatter3d",
                marker = list(size = 3, color = colInliers, 
                              opacity = 0.7, symbol = "circle")) %>%
    layout(title = titleG, scene = myscene)
  for (t in 1:length(taus)){ # t=4
      gridxmat<-rqMod$mod_grid$gridxmat
      RqMod_mat <- rqMod$mod_pred_t %>% 
        filter(tau==taus[t])
      RqMod_mat <- array(RqMod_mat$RqMod,dim=c(graphfine,graphfine))
      pl_3d$all<-pl_3d$all %>% 
          add_surface(x = gridxmat$x, y = gridxmat$y, z = RqMod_mat,
                      opacity = 0.8, colorscale = list(c(0,1),c(blank,colRQ[t])))
  } # taus
  
  # Define surfaces for each tau
  pl_3d$one<-imap(as.list(taus), ~{ #taut=as.list(taus)[[1]] t=1
    gridxmat<-rqMod$mod_grid$gridxmat
    RqMod_mat <- rqMod$mod_pred_t %>% 
      filter(tau==.x)
    RqMod_mat <- array(RqMod_mat$RqMod,dim=c(graphfine,graphfine))
    rqlim <- rqMod$rqlim_t %>% 
      filter(tau==.x)
    rqsup<-rqlim %>% filter(status=="over")
    rqinf<-rqlim %>% filter(status=="under")
      
    plot_ly(showlegend=F, scene=paste("scene",.y,sep="")) %>% 
      add_surface(x = gridxmat$x, 
                  y = gridxmat$y, 
                  z = RqMod_mat,
                  opacity = 0.9, colorscale = list(c(0,1),c(blank,colRQ[.y])),
                  colorbar=list(title=list(
                      text=paste("SDM-NEO\n",
                                 rqMod$meta$unit,"\nTau=",.x,sep="")))) %>%
      add_trace(x = rqsup$x1, y = rqsup$x2, z = rqsup$y, 
                mode = "markers", type = "scatter3d",
                marker = list(size = 3, color = colOutliers, 
                              opacity = 0.7, symbol = "diamond"))%>%
      add_trace(x = rqinf$x1, y = rqinf$x2, z = rqinf$y, 
                mode = "markers", type = "scatter3d",
                marker = list(size = 3, color = colInliers, 
                              opacity = 0.7, symbol = "circle")) %>%
      layout(title = titleG, scene = myscene)
    } ) # map taus
  return(pl_3d)
}

# pl_rq_all_3d<- rq_Mod_sel %>% 
#     map(.,~keep_at(.x,grepl("^RQ2",names(.x))) ) %>% 
#     map_depth(.,2,~pl_rq_Mod_3d(.x,titleG) )

pl_rq_sel_3d<- rq_Mod_sel %>% 
    map(.,~keep_at(.x,grepl("^RQ2",names(.x))) ) %>% 
    map_depth(.,2,~pl_rq_Mod_3d(.x,taus,titleG) )

walk(pl_rq_sel_3d,
  ~{iwalk(., ~ saveWidget(partial_bundle(.x$all),
                          sprintf("%s/%s/%s_%s_3d.html",
                    graph_path, substr(.y,1,6), espece, .y), 
                    selfcontained = F, libdir = "lib") ) } )
```

# GIS results
```{r}
 # load of background for map
# osm_df <- read_osm(bb(Mars_SDM), ext=1, type= "osm") #stamen-watercolor osm
# save(osm_df, file=sprintf("SIG/OSM_extraction.RData"))
load(sprintf("SIG/OSM_extraction.RData"))

graph_path <- sprintf("%s%s/%s/",wdgraph,espece,analysis)
titleG <- sprintf("%s %s in %s",
                  analysis,speciesMP$Taxon_SNa[sp],saison[sai,2])

```

## Mars SDM stats

```{r}
#| label: rq_Mod_mars_stat

st_rq_Mod_map<-function(rqmodmars,rqMod,tauchoice){
    # biolo=reponse[[1]]
    # rqmodmars=rq_Mod_mars_sel[[biolo$rdescr]][[1]]
    # rqMod=rq_Mod_sel[[biolo$rdescr]][[1]]
  
  descr<-list(geog=list(stat.test=NULL,plot=NULL),
              time=list(stat.test=NULL,plot=NULL))

  sdmname<-rqMod$sdmname
  rqmodmars <- rqmodmars %>% 
    st_drop_geometry() %>% 
    filter(grepl("Mudflat",.$Zone)) %>%
    mutate(Zone=fct_drop(.$Zone)) %>% 
    mutate(across(c(Zone,Period),factor))
  
  descr$geog$stat.test <- rqmodmars %>%
    group_by(Zone) %>%
    wilcox_test(as.formula(sprintf("t%.3f ~ Period",tauchoice))) %>%
    add_xy_position(x = "Period",group = "Zone", #scales = "free", 
                    dodge = 0,step.increase = 0.4) %>% #
    filter(p.adj.signif!="ns")
  descr$geog$plot <- ggplot(rqmodmars) +
    # geom_boxplot(aes(x=Period, y = .data[[vars]], fill = Period)) +
    # geom_density_ridges(aes(y = Period , fill=Period,
    #                       x=.data[[vars]]), alpha=0.3) +
    geom_flat_violin(aes(x=Period, fill = Period,
                     y = .data[[sprintf("t%.3f",tauchoice)]] ),
                     alpha = 0.5) +
    stat_summary(aes(x=Period, fill = Period,
                     y = .data[[sprintf("t%.3f",tauchoice)]],color = Period),
                 fun.data = mean_se, show.legend = FALSE) +
    stat_pvalue_manual(descr$geog$stat.test,label = "p.adj.signif", tip.length = 0.02) +
    coord_flip() +
    facet_wrap( ~ Zone, 
               nrow = 1, #scales = "free_y", 
               labeller = label_wrap_gen(width = 10)) + 
    labs(y = rqMod$meta$reponset, x="") +
    Scale_brew() +
    guides(fill=guide_legend(nrow=2,byrow=TRUE)) +
    theme(legend.position="bottom")#,
      # axis.text.x = element_blank(), axis.ticks = element_blank())

  descr$time$stat.test <- rqmodmars %>% 
    group_by(Period) %>%
    wilcox_test(as.formula(sprintf("t%.3f ~ Zone",tauchoice))) %>%
    add_xy_position(x = "Zone",group = "Period", scales = "free", 
                    dodge = 0,step.increase = 0.4) %>%
    filter(p.adj.signif!="ns")
  
  descr$time$plot <- ggplot(rqmodmars) +
    # geom_boxplot(aes(x=Zone, y = .data[[vars]], fill = Zone)) +
    geom_flat_violin(aes(x=Zone, fill = Zone,
                     y = .data[[sprintf("t%.3f",tauchoice)]] ),
                     alpha = 0.5) +
    stat_summary(aes(x=Zone, fill = Zone,
                     y = .data[[sprintf("t%.3f",tauchoice)]],color = Zone),
                 fun.data = mean_se, show.legend = FALSE) +
    stat_pvalue_manual(descr$time$stat.test,label = "p.adj.signif", tip.length = 0.02) +
    coord_flip() +
    facet_wrap( ~ Period, 
               nrow = 1, #scales = "free_y", 
               labeller = label_wrap_gen(width = 10)) + 
    labs(y = rqMod$meta$reponset, x="") +
    Scale_brew() +
    guides(fill=guide_legend(nrow=2,byrow=TRUE)) +
    theme(legend.position="bottom",
      axis.text.x = element_blank(), axis.ticks = element_blank())
}

# pl_rq_mars_all_st<-
#   map(reponse, \(biolo)
#       {map2(rq_Mod_mars_all[[biolo$rdescr]],
#             rq_Mod_all[[biolo$rdescr]],
#            ~st_rq_Mod_map(.x,.y,tauchoice)) } )

pl_rq_mars_sel_st<-
  map(reponse, \(biolo)
      {map2(rq_Mod_mars_sel[[biolo$rdescr]],
            rq_Mod_sel[[biolo$rdescr]],
           ~st_rq_Mod_map(.x,.y,tauchoice)) } )

walk(pl_rq_mars_sel_st,
  ~{iwalk(., ~ggsave(sprintf("%s/%s/%s_%s_mars_st.tiff",
                    graph_path, substr(.y,1,6), espece, .y),
                    plot = .x,
                    width = 10, height = 7, dpi=400) ) } )

```

## Shapefile save
```{r}
# st_write(rq_Mod_mars_sel_per, sprintf("%sLayers made/SDM_NEO_RQ_%s.shp",wdGIS,espece),append=FALSE)
```

## Maps plots
```{r}
#| label: rq_Mod_plot_map

# option tmap version facet
tmap_mode("plot") # "plot" "view"
pl_rq_Mod_map<-function(rqmodmars,rqMod,tauchoice){
    # biolo=reponse[[1]]
    # rqmodmars=rq_Mod_mars_sel[[biolo$rdescr]][[1]]
    # rqMod=rq_Mod_sel[[biolo$rdescr]][[1]]
  vars<-unlist(strsplit(rqMod$meta$predict,rqMod$meta$type,fixed = TRUE))
  varsl<-rqMod$meta$predictl
  sdmname<-rqMod$sdmname

  # # option ggplot
  # tmp_sf <-
    # ggplot(data = rqBmars) +
  #   geom_sf(aes(fill = SDM), color = NA) +
  #   facet_wrap(~Annee) +
  #   labs(x="Latitude",y="Longitude",
  #        fill = sprintf("SDM-NEO\n%s",sdmname)) +
  #   theme(plot.margin = margin(0.05,0.05,0.05,0.05, "cm")) +
  #   scale_fill_distiller(palette = "Spectral")
  
  tm_shape(osm_df) +  
    tm_rgb(saturation = .6, alpha= 0.8) +
  # tm_scale_bar(position = c("left", "bottom"), width = 0.15) + #SCALE
  # tm_compass(position = c("left", "top"), size = 2) +          #NORTH COMPASS
  tm_shape(rqmodmars) +
    tm_fill(col = sprintf("t%.3f",tauchoice), 
            palette = "-Spectral", alpha = 0.7,
            legend.is.portrait = FALSE) +
    # tm_borders("white", lwd = 0) +
    tm_facets(by="Period", ncol = 3) +
  tm_layout(legend.outside = TRUE, 
            legend.outside.position = "bottom",
            outer.margins=c(0,0,0,0), inner.margins=c(0,0,0,0),
            title.size=10)
 }


# pl_rq_all_map<-
#   map(reponse, \(biolo)
#     {map2(rq_Mod_mars_all[[biolo$rdescr]],rq_Mod_sel[[biolo$rdescr]],
#          ~pl_rq_Mod_map(.x,.y,tauchoice)) } )

pl_rq_sel_map<-
  map(reponse, \(biolo)
    {map2(rq_Mod_mars_sel_per[[biolo$rdescr]],rq_Mod_sel[[biolo$rdescr]],
         ~pl_rq_Mod_map(.x,.y,tauchoice)) } )

walk(pl_rq_sel_map,
     ~iwalk(., ~tmap_save(.x, dpi=400,
                          filename=sprintf("%s/%s/%s_%s_map.tiff",
                              graph_path, substr(.y,1,6), espece, .y)) ) )

```

## Animated GIF Maps plots
```{r}
#| label: rq_Mod_plot_map

pl_rq_Mod_map_gif<-function(rqmodmars,sdmname,tauchoice){
    # biolo=reponse[[1]]
    # rqmodmars=rq_Mod_mars_sel[[biolo$rdescr]][[1]]
    # sdmname=names(rq_Mod_mars_sel[[biolo$rdescr]])[1]
  
  tmap_mode("view") # "plot" "view"
  tmp_sf <-
  tm_basemap(leaflet::providers$OpenStreetMap.HOT) +
  tm_shape(rqmodmars) +
    tm_fill(col = sprintf("t%.3f",tauchoice),
            palette = "-Spectral", alpha = 0.7) +
    # tm_borders("white", lwd = 0) +
    tm_facets(along = "Period") +
  tm_layout(legend.outside = TRUE,
              title.size=10)

  tmap_animation(
    tmp_sf, filename = sprintf("%s/%s/%s_%s_map.gif",
                    graph_path, substr(sdmname,1,6), espece, sdmname),
    fps = 1, width = 2000, height = 2000, dpi=600 )

 }

# pl_rq_all_map<-
#   map(reponse, \(biolo)
#     {imap(rq_Mod_mars_all[[biolo$rdescr]],
#          ~pl_rq_Mod_map_gif(.x,.y,tauchoice)) } )

# pl_rq_sel_map<-
#   map(reponse, \(biolo)
#     {imap(rq_Mod_mars_sel_per[[biolo$rdescr]],
#          ~pl_rq_Mod_map_gif(.x,.y,tauchoice)) } )

```

# Final actions and save

Rdata are saved in `rdataout`. An excel file collects data in `r binderout` , with sheets for :

-   data : contains whatever

```{r}
#| label: finalsave_xls
# wb <- loadWorkbook(binderout) # addWorksheet(wb, sheetName = "rql")
# writeData(wb, sheet = "Rq_coeff", x = smrq_l, 
#           startCol = 1, startRow = 1,withFilter = FALSE)
# saveWorkbook(wb,file=binderout, overwrite = TRUE)

```

```{r}
#| label: finalsave_r
#| 

save(list=(ls()[grep("rq_", ls())]),
     file = paste0(rdataout,".RData"))
beepr::beep(2)
```

# Supplementary data

## Software details

::: {.callout-tip collapse="true"}
## Expand for R Session Info

```{r, echo = FALSE}
#| include: true

library(sessioninfo)
pkg_sesh <- session_info(pkgs = "attached")
quarto_version <- system("quarto --version", intern = TRUE)
pkg_sesh$platform$quarto <- paste(
  system("quarto --version", intern = TRUE),
  "@",
  quarto::quarto_path()
  )
pkg_sesh
```
:::

# References {.unnumbered}
